"O большое
1. Основная идея
O большое (Big O notation) — это математическая нотация, которая описывает асимптотическое поведение функций при стремлении аргумента к бесконечности. В информатике и анализе алгоритмов она используется для описания скорости роста времени выполнения алгоритма или объема потребляемой памяти в зависимости от размера входных данных (n).

Главная цель: Позволяет оценить эффективность алгоритма на больших объемах данных, абстрагируясь от:

Скорости процессора

Языка программирования

Конкретной реализации

Константных множителей и слагаемых

О большое описывает худший случай (worst-case scenario) производительности алгоритма.

2. Формальное определение
T(n) = O(f(n)), если существуют положительные константы c и n₀ такие, что для всех n ≥ n₀ выполняется неравенство:
T(n) ≤ c * f(n)

Где:

T(n) — фактическое время работы алгоритма.

f(n) — функция, которая ограничивает рост T(n) сверху.

c — некоторая положительная константа (например, 100).

n₀ — некоторый размер входных данных, начиная с которого неравенство выполняется (например, n > 1000).

Проще говоря: При очень больших n функция T(n) растёт не быстрее, чем f(n) с точностью до постоянного множителя.

3. Основные классы сложности (от лучшего к худшему)
1. O(1) — Константная сложность (Constant Time)
Описание: Время выполнения не зависит от размера входных данных.

Примеры:

Доступ к элементу массива по индексу.

Вставка в начало связного списка (если есть указатель на голову).

Арифметические операции.

2. O(log n) — Логарифмическая сложность (Logarithmic Time)
Описание: Время выполнения растёт логарифмически от n. Очень эффективно.

Примеры:

Бинарный поиск в отсортированном массиве.

Операции в сбалансированном бинарном дереве поиска (AVL, Red-Black Tree).

3. O(n) — Линейная сложность (Linear Time)
Описание: Время выполнения растёт пропорционально размеру входных данных.

Примеры:

Поиск элемента в неотсортированном массиве (в худшем случае).

Обход связного списка.

Поиск максимума/минимума в массиве.

4. O(n log n) — Линейно-логарифмическая сложность (Linearithmic Time)
Описание: Характерна для эффективных алгоритмов сортировки.

Примеры:

Сортировка слиянием (Merge Sort).

Быстрая сортировка (QuickSort) в среднем случае.

Пирамидальная сортировка (Heap Sort).

5. O(n²) — Квадратичная сложность (Quadratic Time)
Описание: Время выполнения пропорционально квадрату размера входных данных. Неэффективно для больших данных.

Примеры:

Сортировка пузырьком (Bubble Sort).

Сортировка выбором (Selection Sort).

Сортировка вставками (Insertion Sort).

Обход матрицы (двойной вложенный цикл).

6. O(2ⁿ) — Экспоненциальная сложность (Exponential Time)
Описание: Время выполнения удваивается с каждым добавлением нового элемента. Чрезвычайно неэффективно.

Примеры:

Наивное решение задачи о Ханойских башнях.

Некоторые алгоритмы, использующие полный перебор (brute-force).

7. O(n!) — Факториальная сложность (Factorial Time)
Описание: Самая медленная. Время выполнения растёт как факториал от n.

Примеры:

Задача коммивояжёра (решение полным перебором).

Генерация всех перестановок множества.

4. Правила упрощения (Анализ сложности)
Отбрасываем константы: O(2n) → O(n), O(500) → O(1)

Отбрасываем неглавные слагаемые: O(n² + n) → O(n²), O(n + log n) → O(n)

Учитываем вложенность: Если внутри цикла по n находится другой цикл по n, то сложность O(n²).

Разные входные данные: Если алгоритм принимает два аргумента разной длины (m и n), сложность может быть O(m * n).

5. Почему это важно?
Масштабируемость: Алгоритм с O(n log n) будет работать на миллионе элементов в тысячи раз быстрее, чем алгоритм с O(n²).

Выбор алгоритма: Позволяет objectively выбрать наиболее подходящий алгоритм для решаемой задачи.

Проектирование систем: Помогает предсказать, как система будет вести себя под нагрузкой при росте числа пользователей или данных.