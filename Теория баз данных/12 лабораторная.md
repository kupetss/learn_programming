## Задание 1: Базовая транзакция (COMMIT)
Переформулировка примера с COMMIT. Напишите транзакцию, которая переводит 150 денежных единиц со счета 1 на счет 2. После выполнения обоих UPDATE убедитесь, что изменения постоянны, используя COMMIT. В конце выведите данные из таблицы Accounts.

## Задание 2: Отмена транзакции (ROLLBACK)
Переформулировка примера с ROLLBACK. Начните транзакцию. Попытайтесь списать со счета 2 сумму в 500 денежных единиц. Проверьте, не стал ли баланс отрицательным. Если баланс меньше нуля, выведите сообщение "Недостаточно средств!" и выполните ROLLBACK. В конце убедитесь, что баланс счета 2 не изменился.

## Задание 3: Использование @@ERROR
Напишите транзакцию, которая включает два действия: уменьшает баланс счета 1 на 50, а затем пытается вставить запись в несуществующую таблицу TransactionHistory (это вызовет ошибку). Используйте системную переменную @@ERROR после каждой операции. Если хотя бы одна ошибка произошла ( @@ERROR <> 0 ), откатите всю транзакцию с помощью ROLLBACK.

## Задание 4: Точка сохранения (SAVE TRANSACTION)
Начните транзакцию. Выполните корректный UPDATE, уменьшающий баланс счета 1 на 100. Создайте точку сохранения с именем BeforeSecondUpdate. Затем выполните UPDATE, который попытается зачислить 100 на несуществующий счет 999. Если вторая операция не затронула строки ( @@ROWCOUNT = 0 ), откатитесь только до точки сохранения BeforeSecondUpdate. После этого зачислите 100 на счет 2. Завершите транзакцию коммитом.

## Задание 5: Транзакция внутри процедуры
Напишите хранимую процедуру usp_DepositMoney, которая принимает параметры @AccountID INT и @Amount MONEY. Процедура должна увеличивать баланс указанного счета на переданную сумму внутри транзакции. Используйте переменную для суммирования кодов ошибок ( @@ERROR ) после операции UPDATE. Если итоговый код ошибки равен 0, коммитьте транзакцию и возвращайте 1. В противном случае откатывайте транзакцию и возвращайте 0.

## Задание 6: Простая обработка ошибок (TRY...CATCH)
Используя блок BEGIN TRY...BEGIN CATCH, попытайтесь выполнить операцию деления на ноль: SELECT 100 / 0;. В блоке CATCH выведите информационные сообщения, используя функции ERROR_MESSAGE() и ERROR_NUMBER().

## Задание 7: Анализ ошибки в CATCH
Напишите блок TRY...CATCH, в котором попытайтесь вставить новую запись в таблицу Accounts с AccountID = 1 (это вызовет ошибку нарушения первичного ключа). В блоке CATCH проверьте номер ошибки с помощью ERROR_NUMBER(). Если ошибка имеет номер 2627, выведите сообщение "Ошибка: счет с таким ID уже существует.". Для любой другой ошибки выведите сообщение "Произошла неизвестная ошибка.".

## Задание 8: Безопасная процедура с TRY...CATCH
Перепишите процедуру перевода денег из Задания 5 (или конспекта), используя блок TRY...CATCH. Процедура usp_SafeTransfer должна принимать параметры @FromAccount INT, @ToAccount INT, @Amount MONEY. В блоке TRY начните транзакцию, выполните оба UPDATE. Если какой-либо счет не найден ( @@ROWCOUNT = 0 ), сгенерируйте ошибку с помощью RAISERROR. В блоке CATCH выполните ROLLBACK, залогируйте ошибку в таблицу ErrorLog и пробросьте ошибку обратно с помощью RAISERROR.

## Задание 9: Генерация пользовательской ошибки
Напишите код, который проверяет баланс счета 1. Если баланс превышает 1500 денежных единиц, сгенерируйте пользовательскую ошибку с помощью RAISERROR с текстом "Баланс счета превышает допустимый лимит!" и уровнем серьезности 16. Обработайте эту ошибку в блоке CATCH, выведя сообщение.

## Задание 10: Логирование ошибок
Создайте хранимую процедуру usp_DivideNumbers, которая принимает два числа @a INT, @b INT и пытается разделить первое на второе внутри блока TRY. В блоке CATCH занесите все детали ошибки (номер, серьезность, состояние, процедуру, строку, сообщение) в таблицу ErrorLog. Не пробрасывайте ошибку выше, а просто выведите сообщение "Ошибка залогирована, ID: ...", используя SCOPE_IDENTITY() для отображения ID новой записи в логе.

## Задание 11: Комбинирование транзакции и TRY...CATCH
Напишите транзакцию, которая внутри блока TRY выполняет два действия: списывает 200 со счета 2 и зачисляет 200 на счет 1. В блоке CATCH обязательно проверьте, открыта ли еще транзакция ( @@TRANCOUNT > 0 ), и если да, выполните ROLLBACK. Также выведите сообщение об ошибке.

## Задание 12: Вложенная ошибка
Используя блок TRY внутри другого блока TRY, создайте "двойную" ошибку. Во внешнем блоке TRY выполните команду, вызывающую ошибку (например, SELECT 1/0;). Во внутреннем блоке TRY также вызовите ошибку (например, вставку дубликата ключа). Проанализируйте, какой блок CATCH сработает первым и какая ошибка будет обработана.