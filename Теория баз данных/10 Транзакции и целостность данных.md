# 10 Транзакции и целостность данных
## База
```sql
-- Создаем простую базу данных для демонстрации
CREATE DATABASE BankDemo;
GO

USE BankDemo;
GO

-- Таблица счетов
CREATE TABLE Accounts (
    AccountID INT PRIMARY KEY,
    Balance MONEY NOT NULL
);
GO

-- Вставляем тестовые данные
INSERT INTO Accounts (AccountID, Balance) VALUES (1, 1000.00); -- Счет №1
INSERT INTO Accounts (AccountID, Balance) VALUES (2, 200.00);  -- Счет №2
GO

-- Посмотрим на начальное состояние
SELECT * FROM Accounts;
```

## COMMIT
```sql
-- Начинаем транзакцию
BEGIN TRANSACTION; -- Говорим SQL Server: "Внимание, начинается группа важных операций!"

-- 1. Списываем 100 денег со счета 1
UPDATE Accounts
SET Balance = Balance - 100
WHERE AccountID = 1;

-- 2. Зачисляем 100 денег на счет 2
UPDATE Accounts
SET Balance = Balance + 100
WHERE AccountID = 2;

-- Проверяем результат внутри транзакции
-- На этом этапе другие пользователи еще НЕ видят эти изменения!
SELECT * FROM Accounts;

-- Если нас все устраивает (оба UPDATE выполнились без ошибок)...
COMMIT TRANSACTION; -- Говорим SQL Server: "ВСЕ ОТЛИЧНО! Сохраняй изменения навсегда!"

-- Теперь изменения постоянны и видны всем.
SELECT * FROM Accounts; -- Балансы изменены: 1=900, 2=300
```
## ROLLBACK
```sql
-- Начинаем новую транзакцию
BEGIN TRANSACTION; -- "Снова начинаем группу операций"

-- 1. Пытаемся списать 2000 денег со счета 2 (но там всего 300!)
UPDATE Accounts
SET Balance = Balance - 2000
WHERE AccountID = 2;
-- Сама команда UPDATE выполнится без ошибки синтаксиса, но логически это ошибка.

-- Давайте проверим результат этого безумного действия
DECLARE @CurrentBalance MONEY;
SELECT @CurrentBalance = Balance FROM Accounts WHERE AccountID = 2;

-- Используем условную конструкцию IF, которую мы уже проходили
IF @CurrentBalance < 0
BEGIN
    PRINT 'На счету недостаточно средств! Транзакция отменяется.';
    ROLLBACK TRANSACTION; -- Говорим SQL Server: "ВСЕ ПРОПАЛО! ОТМЕНИ ВСЕ ИЗМЕНЕНИЯ, сделанные после BEGIN TRANSACTION!"
END
ELSE
BEGIN
    PRINT 'Средства списаны. Транзакция подтверждается.';
    COMMIT TRANSACTION;
END

-- Проверяем состояние после ROLLBACK
-- Поскольку мы откатили транзакцию, UPDATE отменился, и баланс на счете 2 остался прежним (300).
SELECT * FROM Accounts WHERE AccountID = 2;
```

## @@ERROR
```sql
-- Начинаем транзакцию
BEGIN TRANSACTION;

-- 1. Успешная операция
UPDATE Accounts SET Balance = Balance - 50 WHERE AccountID = 1;

-- 2. Операция, которая приведет к ошибке (попытка вставить дубликат PRIMARY KEY)
-- Допустим, у нас есть таблица с историей переводов, и мы пытаемся вставить запись с уже существующим ID.
INSERT INTO TransferHistory (TransferID, FromAccount, Amount) VALUES (1, 1, 50);
-- Предположим, что запись с TransferID = 1 уже существует, поэтому здесь возникнет ошибка.

-- Проверяем, возникла ли ошибка после последней операции
IF @@ERROR <> 0 -- @@ERROR - системная переменная, которая возвращает номер ошибки последней выполненной команды.
BEGIN
    PRINT 'Произошла ошибка! Откатываем все изменения.';
    ROLLBACK TRANSACTION; -- Откатываем и успешный UPDATE, и неудачный INSERT.
END
ELSE
BEGIN
    COMMIT TRANSACTION;
END
```

## SAVE TRANSACTION
```sql
USE BankDemo;
GO

BEGIN TRANSACTION; -- Начало основной транзакции

-- Операция 1: Успешное списание
UPDATE Accounts SET Balance = Balance - 100 WHERE AccountID = 1;
PRINT 'Списание 100 у.е. со счета 1 выполнено.';

-- Устанавливаем точку сохранения с именем "SavePointAfterFirstUpdate"
SAVE TRANSACTION SavePointAfterFirstUpdate;
PRINT 'Создана точка сохранения.';

-- Операция 2: Потенциально опасная операция (например, зачисление на несуществующий счет)
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 999; -- Счета 999 нет!
-- Команда выполнится (ошибки синтаксиса нет), но число затронутых строк будет 0.
IF @@ROWCOUNT = 0 -- Проверяем, была ли затронута хоть одна строка
BEGIN
    PRINT 'Ошибка: Целевой счет для зачисления не найден!';
    -- Откатываемся только до нашей точки сохранения, а не на всю транзакцию
    ROLLBACK TRANSACTION SavePointAfterFirstUpdate;
    PRINT 'Откат до точки сохранения выполнен. Первое изменение еще в транзакции.';
END

-- Проверяем состояние данных на данный момент.
-- Первое UPDATE осталось в силе (но не закоммичено), второе - отменено.
SELECT * FROM Accounts;

-- Мы можем повторить failed операцию или сделать что-то еще...
UPDATE Accounts SET Balance = Balance + 100 WHERE AccountID = 2; -- Зачисляем на верный счет 2
PRINT 'Зачисление на счет 2 выполнено успешно.';

-- Если теперь все хорошо, коммитим всю транзакцию
COMMIT TRANSACTION;
PRINT 'Транзакция завершена успешно. Все изменения сохранены.';

-- Финальный результат: Со счета 1 списано 100, на счет 2 зачислено 100.
SELECT * FROM Accounts;
```

## Транзакция в процедуре с возвратом статуса ошибки
```sql
-- Создадим процедуру для перевода денег
CREATE PROCEDURE pTransferMoney
    @FromAccount INT,
    @ToAccount INT,
    @Amount MONEY
AS
BEGIN
    -- Объявляем переменную для контроля ошибок
    DECLARE @ErrorCode INT = 0;

    -- Начинаем транзакцию
    BEGIN TRANSACTION;

    -- 1. Списание средств
    UPDATE Accounts SET Balance = Balance - @Amount WHERE AccountID = @FromAccount;
    SET @ErrorCode = @ErrorCode + @@ERROR; -- Если ошибка, @@ERROR будет > 0

    -- 2. Зачисление средств
    UPDATE Accounts SET Balance = Balance + @Amount WHERE AccountID = @ToAccount;
    SET @ErrorCode = @ErrorCode + @@ERROR;

    -- Проверяем, не ушел ли баланс в минус (логическая ошибка)
    IF EXISTS (SELECT * FROM Accounts WHERE AccountID = @FromAccount AND Balance < 0)
    BEGIN
        SET @ErrorCode = @ErrorCode + 1; -- Имитируем ошибку
        PRINT 'Ошибка: Недостаточно средств на счете отправителя.';
    END

    -- Принимаем решение: коммит или роллбэк
    IF @ErrorCode = 0
    BEGIN
        COMMIT TRANSACTION;
        PRINT 'Перевод выполнен успешно.';
        RETURN 1; -- Возвращаем код успеха
    END
    ELSE
    BEGIN
        ROLLBACK TRANSACTION;
        PRINT 'Произошла ошибка. Перевод отменен.';
        RETURN 0; -- Возвращаем код ошибки
    END
END
GO

-- Вызываем процедуру (успешно)
DECLARE @Result INT;
EXEC @Result = pTransferMoney @FromAccount = 1, @ToAccount = 2, @Amount = 50;
PRINT 'Результат выполнения процедуры: ' + CAST(@Result AS VARCHAR);

-- Вызываем процедуру (неуспешно, недостаточно средств)
DECLARE @Result2 INT;
EXEC @Result2 = pTransferMoney @FromAccount = 2, @ToAccount = 1, @Amount = 10000;
PRINT 'Результат выполнения процедуры: ' + CAST(@Result2 AS VARCHAR);
```